\\x1f679d9ba17102fe3711460718f55034c97376a18a0e4d366fe24b1fc693da06	datum-plv8
\\x5aed3b40c04ba9727c3eaa3284b8c73416ec9f642085a475372533324fb7eb82	plv8.elog(WARNING,'Loading datum-plv8.js......');\n\nvar AQ = AQ || {};\n\nAQ.uuid = function() {\n    var d = new Date().getTime();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (d + Math.random()*16)%16 | 0;\n        d = Math.floor(d/16);\n        return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n    });\n}\n\n\nfunction query_options( options ) {\n\n    var keys = [];\n\n    if (typeof options != 'undefined') {\n\n        // Meta data defaults to true;\n        if (typeof options.meta_data == 'undefined') {\n            options.meta_data = true;\n        }\n\n        // Map the keys of the options object to an array of encoded url components\n        Object.keys(options).sort().map(function(key_name) {\n\n            var key = options[key_name];\n\n            switch(key_name) {\n\n                case 'where':\n                    // where: { name: 'column_name', op: '=', value: 'value' }\n                    // where: [{ name: 'column_name', op: '=', value: 'value' }]\n                    if (typeof key.length == 'undefined') key = [key];\n\n                    return key.map(function(where) {\n                        return 'where=' + encodeURIComponent(JSON.stringify(where));\n                    }).join('&');\n\n                case 'order_by':\n                    // So many possibilities...\n                    // order_by: '-?column_name'\n                    // order_by: ['-?column_name']\n                    // order_by: { 'column_name': 'asc|desc' }\n                    // order_by: [{ 'column_name': 'asc|desc' }]\n                    // order_by: { column: 'column_name', direction: 'asc|desc' }\n                    // order_by: [{ column: 'column_name', direction: 'asc|desc' }]\n                    if (typeof key.length == 'undefined') key = [key];\n\n                    return key_name + '=' + encodeURIComponent(key.map(function(o,i) {\n                        return ((typeof o.direction != 'undefined' && o.direction != 'asc') ? '-' : '') + o.column;\n                    }).join(','));\n\n                case 'limit':\n                    // limit: number\n                case 'offset':\n                    // offset: number\n                    var parsedNum = parseInt(key);\n                    if (!isNaN(parsedNum)) {\n                        return key_name + '=' + parsedNum;\n                    }\n                    return;\n                case 'meta_data':\n                case 'args':\n                case 'exclude':\n                case 'include':\n                    return key_name + '=' + encodeURIComponent(JSON.stringify(key));\n            }\n        }\n\n                                        // Remove all undefined elements of the array\n                                       ).forEach(function(e) {\n            if (typeof e != 'undefined') keys.push(e);\n        });\n    }\n\n    // Return the query string by joining the array with &'s\n    return keys.length ? '?' + keys.join('&') : '?';\n}\n\n\n\n/*--------------------------------- * Database * ---------------------------------*/\nfunction Endpoint( url ) {\n\n    this.url = url;\n    \n    var resource = function( method, meta_id, args, data ) {\n\n        args = args || {};\n\n        // URLs\n        var id_url = meta_id.to_url(true); // ID part of the URL only\n        var url_without_query = this.url + id_url;\n        var query_ops = query_options(args);\n        var url_with_query = url_without_query + query_ops;\n\n        // Settings object to send with 'fetch' method\n        var init_obj = {\n            method: method\n        };\n\n        // Don't add data on GET requests\n        if (method != 'GET') {\n            init_obj.body = JSON.stringify(data);\n        }\n\n        // var request = fetch(method == 'GET' ? url_with_query : url_without_query, init_obj);\n        var request = {\n            "then": function(f) {\n                plv8.elog(WARNING, 'THEN: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            },\n            "catch": function(f) {\n                plv8.elog(WARNING, 'CATCH: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            },\n            "bind": function(f) {\n                plv8.elog(WARNING, 'BIND: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            }\n        }\n\n        var response = plv8.execute('select * from endpoint.request($1,$2,$3,$4,$5)', [\n            '0.2',\n            method,\n            url_without_query,\n            JSON.stringify(query_ops),\n            '{}'\n        ]);\n\n        plv8.elog(WARNING, 'FAT ASS RESPONSE: '+JSON.stringify(response));\n\n        // Read json stream\n        /*\n        var json = response.json();\n\n        if (response.status >= 200 && response.status < 300) {\n            return json;\n        }\n        */\n        \n        return request;\n    }\n\n/*\n\treturn {\n        url: this.url,\n        get: function( meta_id, args )        { return resource.call(this, 'GET', meta_id, args); }.bind(this),\n        post: function( meta_id, data )       { return resource.call(this, 'POST', meta_id, {}, data); }.bind(this),\n            patch: function( meta_id, data )      { return resource.call(this, 'PATCH', meta_id, {}, data); }.bind(this),\n                delete: function( meta_id, args )     { return resource.call(this, 'DELETE', meta_id, args); }.bind(this)\n};\n*/\n    \n    \n    \n    return {\n        "url": this.url,\n        "get": function( meta_id, args )        { return resource.call(this, 'GET', meta_id, args); },\n        "post": function( meta_id, data )       { return resource.call(this, 'POST', meta_id, {}, data); },\n        "patch": function( meta_id, data )      { return resource.call(this, 'PATCH', meta_id, {}, data); },\n        "delete": function( meta_id, args )     { return resource.call(this, 'DELETE', meta_id, args); }\n    };\n}\n\n\n/*--------------------------------- * Database * ---------------------------------*/\nAQ.Database = function( url, settings ) {\n    this.settings = settings;\n\n    // Not sure which name is better\n    this.endpoint = this.connection = new Endpoint(url);\n    this.query_string = query_options;\n};\nAQ.Database.prototype.constructor = AQ.Database;\nAQ.Database.prototype.schema = function( name ) { return new AQ.Schema(this, name); };\n\n/*--------------------------------- * Schema * ---------------------------------*/\nAQ.Schema = function( database, name ) {\n    this.database = database;\n    this.name = name;\n    this.id = { name: this.name };\n};\nAQ.Schema.prototype.constructor = AQ.Schema;\nAQ.Schema.prototype.relation = function( name )         { return new AQ.Relation(this, name); };\nAQ.Schema.prototype.table = function( name )            { return new AQ.Table(this, name); };\nAQ.Schema.prototype.view = function( name )             { return new AQ.View(this, name); };\nAQ.Schema.prototype.function = function( identifier, args, options )   {\n\n    // Function identifier (name and parameter list)\n    if (typeof identifier == 'object') {\n        var name = identifier.name;\n        var parameter_type_list = identifier.parameters;\n    }\n    // Selecting a function without specifying the parameters\n    else {\n        var name = identifier;\n    }\n\n    options = options || {};\n\n    // Arguments\n    options.args = {};\n\n    // `args = undefined` will pass no arguments into the server-side function\n    if (typeof args != 'undefined') {\n\n        // some_function?args={ kwargs: {} } -- Key/value object\n        if (!(args instanceof Array) && args instanceof Object) {\n            options.args.kwargs = args;\n        }\n        // some_function?args={ vals: [] } -- Array\n        else {\n            if (!(args instanceof Array)) {\n                // Regular value is placed into array\n                args = [ args ];\n            }\n            options.args.vals = args;\n        }\n    }\n\n    var fn = new AQ.Function(this, name, parameter_type_list);\n\n    return this.database.endpoint.get(fn, options)\n    .then(function(response) {\n\n        if (!response) {\n            throw 'Empty response';\n        }\n        else if (!response.result.length) {\n            throw 'Result set empty';\n        }\n        if(response.result.length > 1) {\n            return new AQ.FunctionResultSet(fn, response);\n        }\n        return new AQ.FunctionResult(fn, response);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Function call request failed: ' + err;\n    });\n};\n\n/*--------------------------------- * Relation * ---------------------------------*/\nAQ.Relation = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.Relation.prototype.constructor = AQ.Relation;\nAQ.Relation.prototype.to_url = function( id_only ) {\n    return id_only ? '/relation/' + this.schema.name + '/' + this.name :\n    this.schema.database.endpoint.url + '/relation/' + this.schema.name + '/' + this.name;\n};\nAQ.Relation.prototype.column = function( name ) {\n    return new AQ.Column(this, name);\n};\nAQ.Relation.prototype.rows = function( options ) {\n\n    return this.schema.database.endpoint.get(this, options)\n    .then(function(rows) {\n\n        if (rows == null) {\n            throw 'Empty response';\n        }/*\n                else if (rows.result.length < 1) {\n                    throw 'No rows returned';\n                }*/\n        return new AQ.Rowset(this, rows, options);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Rows request failed: ' + err;\n    });\n};\nAQ.Relation.prototype.row = function() {\n\n    // Multiple different ways to call 'row' function\n\n    // 1. Calling with Options object\n    if (typeof arguments[0] == 'object') {\n\n        var obj = arguments[0];\n        var args = arguments[1] || {};\n\n        // AQ.Relation.row({ where: { column_name: 'column_name', op: '=', value: 'value' } })\n        // Maybe it should be this one: AQ.Relation.row({ where: { column_name: value } })\n        if (typeof obj.where != 'undefined') {\n            args.where = obj.where;\n        }\n        // AQ.Relation.row({ column_name: 'column_name', op: '=', value: 'value' })\n        // Maybe it should be this one: AQ.Relation.row({ column_name: value })\n        else {\n            args.where = obj;\n        }\n\n    }\n    // 2. Calling with column_name and value\n    else if (typeof arguments[0] == 'string') {\n\n        // AQ.Relation.row(column_name, value [, options_obj])\n        var name = arguments[0];\n        var value = arguments[1];\n        var args = arguments[2] || {};\n\n        args.where = { name: name, op: '=', value: value };\n\n    }\n    // 3. Calling AQ.Relation.row() without arguments\n    else {\n        var args = {};\n    }\n\n    return this.schema.database.endpoint.get(this, args)\n    .then(function(row) {\n\n        if (row == null) {\n            throw 'Empty response';\n        }\n        else if (row.result.length == 0) {\n            throw 'No row returned';\n        }\n        else if (row.result.length > 1) {\n            throw 'Multiple rows returned';\n        }\n        return new AQ.Row(this, row);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Row request failed: ' + err;\n    });\n};\n\n/*--------------------------------- * Table * ---------------------------------*/\nAQ.Table = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.Table.prototype = Object.create(AQ.Relation.prototype);\nAQ.Table.prototype.constructor = AQ.Table;\nAQ.Table.prototype.insert = function( data ) {\n\n    if (typeof data == 'undefined') {\n        // table.insert({}) is equivalent to table.insert()\n        // both will insert default values\n        data = {};\n    }\n\n    // Return inserted row promise\n    return this.schema.database.endpoint.patch(this, data)\n    .then(function(inserted_row) {\n\n        if (inserted_row == null) {\n            throw 'Empty response';\n        }\n        if (typeof data.length != 'undefined' && data.length > 1) {\n            return new AQ.Rowset(this, inserted_row, null);\n        }\n        return new AQ.Row(this, inserted_row);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Insert failed: ' + err;\n    });\n\n};\n\n/*--------------------------------- * View * ---------------------------------*/\nAQ.View = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.View.prototype = Object.create(AQ.Relation.prototype);\nAQ.View.prototype.constructor = AQ.View;\n\n/*--------------------------------- * Rowset * ---------------------------------*/\nAQ.Rowset = function( relation, response, server_arguments ) {\n    this.relation = relation;\n    this.schema = relation.schema;\n    this.columns = response.columns || null;\n    this.pk_column_name = response.pk || null;\n    this.rows = response.result;\n    this.length = response.result.length;\n    this.server_arguments = server_arguments || {};\n};\nAQ.Rowset.prototype.constructor = AQ.Rowset;\nAQ.Rowset.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.Rowset.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.Rowset.prototype.reload = function() {\n    return this.relation.rows(this.server_arguments);\n};\n\n/**\n     * Call AQ.Rowset.where with (where_obj) or use shorthand notation (field, value) - filter results programmatically\n     *\n     * @param {Object} where_obj\n     * @param {[Boolean]} return_first\n     * @param {[Boolean]} async\n     *\n     * OR\n     *\n     * @param {String} field\n     * @param {Any} value\n     * @param {[Boolean]} return_first\n     * @param {[Boolean]} async\n     *\n     * @returns {Promise}\n     */\nAQ.Rowset.prototype.where = function() {\n\n    var first = false, async = true, where_obj = {};\n    if (typeof arguments[0] == 'object') {\n        // AQ.Rowset.where(where_obj [, return_first] [, async]);\n        where_obj = arguments[0];\n        var field = where_obj.field;\n        var value = where_obj.value;\n        if (arguments.length > 1) first = arguments[1];\n        if (arguments.length > 2) async = arguments[2];\n\n    }\n    else if (typeof arguments[0] == 'string' && arguments.length > 1) {\n        // AQ.Rowset.where(field, value [, return_first] [, async]);\n        var field = arguments[0];\n        var value = arguments[1];\n        if (arguments.length > 2) first = arguments[2];\n        if (arguments.length > 3) async = arguments[3];\n    }\n\n    return new Promise(function(resolve, reject) {\n\n        // TODO lots of logic here\n        // The new rowset that is returned must be in the same format as the response from the server\n\n        if (first) {\n            for (var i = 0; i < this.rows.length; i++) {\n                if (this.rows[i].row[field] == value) {\n                    resolve(new AQ.Row(this.relation, { columns: this.columns, result: [ this.rows[i] ] }));\n                }\n            }\n            reject('could not find ' + field + ' ' + value);\n        }\n        else {\n            var return_rowset = [];\n            for (var i = 0; i < this.rows.length; i++) {\n                if (this.rows[i].row[field] == value) {\n                    return_rowset.push(this.rows[i]);\n                }\n            }\n            resolve(new AQ.Rowset(this.relation, { columns: this.columns, result: return_rowset }));\n        }\n\n\n        // 2\n\n        // maybe we don't need to search the entire row and instead we return the first item found\n        /*\n            var new_rowset = _.filter(this.rows, function(el) {\n                //return AQ.equals.call(this, el[field], val);\n            });\n*/\n        if (new_rowset.length == 1) {\n            return new AQ.Row(this.relation, new_rowset);\n        }\n        else if (new_rowset.length > 1) {\n            throw 'Multiple Rows Returned';\n        }\n\n        // if row does not exist\n        return null;\n\n    }.bind(this));\n\n};\nAQ.Rowset.prototype.order_by = function( column, direction ) {\n    /*\n        var ordered = _.sortBy(this.rows, function(el) {\n            return el.row[column];\n        });\n*/\n    if (direction !== 'asc') {\n        ordered.reverse();\n    }\n    return new AQ.Rowset(this.relation, { columns: this.columns, result: ordered });\n};\nAQ.Rowset.prototype.limit = function( lim ) {\n    if (lim <= 0) {\n        throw 'Bad limit';\n    }\n    return new AQ.Rowset(this.relation, { columns: this.columns, result: this.rows.slice(0, lim) });\n};\nAQ.Rowset.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.Rowset.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n\n};\n\n/*--------------------------------- * Row * ---------------------------------*/\nAQ.Row = function( relation, response ) {\n    this.relation = relation;\n    this.schema = relation.schema;\n    this.row_data = response.result[0].row;\n\n    this.cached_fields = {};\n    this.columns = response.columns || null;\n    this.pk_column_name = null;\n    this.pk_value = null;\n    this.id = null;\n    this.to_url = function() {\n        console.error('You must call a row with "meta_data: true" in order to use the to_url function');\n        throw 'Datum.js: Programming Error';\n    };\n\n    if (typeof response.pk != 'undefined') {\n        this.pk_column_name = response.pk;\n        this.pk_value = this.get(this.pk_column_name);\n        // this.id = {"pk_column_id":{"relation_id":{"schema_id":{"name":this.schema.name},"name":this.relation.name},"name":this.pk_column_name},"pk_value": this.pk_value}\n        this.id = {\n            pk_column_id: {\n                relation_id: this.relation.id,\n                name: this.pk_column_name\n            },\n            pk_value: this.pk_value\n        };\n\n        this.to_url = function( id_only ) {\n            return id_only ? '/row/' + this.relation.schema.name + '/' + this.relation.name + '/' + /*JSON.stringify(this.pk_value)*/ this.pk_value :\n            this.relation.schema.database.endpoint.url + '/row/' + this.relation.schema.name + '/' + this.relation.name + '/' + /*JSON.stringify(this.pk_value)*/ this.pk_value;\n        };\n\n    }\n};\nAQ.Row.prototype = {\n    constructor: AQ.Row,\n    get: function( name )           { return this.row_data[name]; },\n    set: function( name, value )    { this.row_data[name] = value; return this; },\n    to_string: function()           { return JSON.stringify(this.row_data); },\n    clone: function()               { return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [{ row: this.row_data }]}); },\n    field: function( name ) {\n        if (typeof this.cached_fields[name] == 'undefined') {\n            this.cached_fields[name] = new AQ.Field(this, name, name === this.pk_column_name);\n        }\n        return this.cached_fields[name];\n    },\n    fields: function() {\n        if (this.columns != null) {\n            return this.columns.map(function(c) {\n                return this.field(c.name);\n            }.bind(this));\n        }\n        return null;\n    }\n};\nAQ.Row.prototype.update = function() {\n    return this.relation.schema.database.endpoint.patch(this, this.row_data)\n    .then(function(response) {\n\n        if(response == null) {\n            throw 'Empty response';\n        }\n        return this;\n\n    }.bind(this)).catch(function(err) {\n        throw 'Update failed: ' + err;\n    });\n};\nAQ.Row.prototype.delete = function() { \n    return this.relation.schema.database.endpoint.delete(this)\n    .then(function(response) {\n\n        if(response == null) {\n            throw 'Empty response';\n        }\n\n    }).catch(function(err) {\n        throw 'Delete failed: ' + err;\n    });\n};\nAQ.Row.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options )  {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.Row.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n};\n\n/*--------------------------------- * Column * ---------------------------------*/\nAQ.Column = function( relation, name ) {\n    this.relation = relation;\n    this.name = name;\n    this.id = { relation_id: relation.id, name: name };\n};\nAQ.Column.prototype.constructor = AQ.Column;\n\n/*--------------------------------- * Field * ---------------------------------*/\nAQ.Field = function( row, name, pk ) {\n    this.row = row;\n    this.column = new AQ.Column(row.relation, name);\n    this.is_primary_key = pk;\n    this.name = name;\n    this.value = row.get(name);\n    this.id = { row_id: this.row.id, column_id: this.column.id };\n    this.to_url = function( id_only ) {\n        if (this.row.pk_value == null) {\n            console.error('You must call a row with "meta_data: true" in order to use the to_url function');\n            throw 'Datum.js: Programming Error';\n        }\n        return id_only ? '/field/' + this.row.relation.schema.name + '/' + this.row.relation.name + '/' + /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value + '/' + this.column.name :\n        this.row.relation.schema.database.endpoint.url + '/field/' + this.row.relation.schema.name + '/' + this.row.relation.name + '/' + /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value + '/' + this.column.name;\n    };\n};\nAQ.Field.prototype = {\n    constructor: AQ.Field,\n    get: function()          { return this.row.get(this.name); },\n    set: function(value)     { this.value = value; return this.row.set(this.name, value); },\n    update: function()       { return this.row.update(); } // TODO: This is wrong\n};\n\n/*--------------------------------- * Function * ---------------------------------*/\nAQ.Function = function( schema, name, args ) {\n    this.schema = schema;\n    this.name = name;\n\n    if(args instanceof Array) {\n        this.args = '{' + args.join(',') + '}';\n    }\n    else {\n        this.args = args;\n    }\n\n    this.id = { schema_id: this.schema.id, name: this.name, args: this.args };\n    this.to_url = function( id_only ) {\n        var base_url = id_only ? '' : this.schema.database.endpoint.url;\n        if (typeof this.args != 'undefined') {\n            return base_url + '/function/' + this.schema.name + '/' + this.name + '/' + this.args;\n        }\n        return base_url + '/function/' + this.schema.name + '/' + this.name;\n    };\n};\nAQ.Function.prototype.constructor = AQ.Function;\n\n/*--------------------------------- * Function Result * ---------------------------------*/\nAQ.FunctionResult = function( fn, response ) {\n    this.function = fn;\n    this.schema = fn.schema;\n    this.row_data = response.result[0].row;\n    this.rows = response.result;\n    this.columns = response.columns;\n};\nAQ.FunctionResult.prototype = {\n    constructor: AQ.FunctionResult,\n    get: function( name )           { return this.row_data[name]; },\n    to_string: function()           { return JSON.stringify(this.row_data); }\n};\nAQ.FunctionResult.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.FunctionResult.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.FunctionResult.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options )  {\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.FunctionResult.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n};\n\n/*--------------------------------- * Function Result Set * ---------------------------------*/\nAQ.FunctionResultSet = function( fn, response ) {\n    this.function = fn;\n    this.schema = fn.schema;\n    this.columns = response.columns;\n    this.rows = response.result;\n};\nAQ.FunctionResultSet.prototype.constructor = AQ.FunctionResultSet;\nAQ.FunctionResultSet.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.FunctionResultSet.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.FunctionResultSet.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.FunctionResultSet.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n\n};\n\n\n\nvar endpoint = new AQ.Database();\n
\\x699ec770fcc3d1a0e97410d0e7567abf5f1aeec49da979b087d4ff3ac8d42850	c8b9c599-9d1b-417a-8e29-43080bb7dd88
\\x911fc0c48cb0c70601db5775a9bef1b740dc4cc9f9b46389b9f0563fe7eb94d7	0.2.0
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
